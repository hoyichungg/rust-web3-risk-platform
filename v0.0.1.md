1. 先對齊一下「現況缺口」

你現在的狀態可以簡化成：
	•	鏈接 & 身分
	•	✅ Axum + Postgres 接好了
	•	✅ SIWE + RoleManager 已經會上鏈查角色
	•	✅ Session / Wallet / Profile / Alert / Strategy 有表、有 repo
	•	投組 / 資產
	•	✅ DbPortfolioService 會定期讀 RPC算 ETH + ERC20 餘額
	•	❌ 價格還是 .env 的 TOKEN_PRICES 靜態值
	•	❌ 沒有歷史快照 / 歷史 PnL，只是「當下狀態」
	•	策略 & 回測
	•	✅ backend/api/src/routes/strategies.rs 已有回測入口
	•	❌ 回測價格是「隨機合成序列」
	•	❌ 策略引擎 / 告警引擎都還是 in-memory，不靠 DB、沒有穩定排程
	•	前端
	•	✅ Next.js + MUI 已經完整串 API
	•	❌ Dashboard 看得到 portfolio/wallet/alerts/strategies，但都是「單一時間點 + 假價」
	•	❌ 缺少「真實行情 + 歷史曲線 + 多資產視角」
	•	合約
	•	✅ RoleManager.sol 已寫好
	•	❌ 還需要 Anvil/Hardhat 常駐 & 部署 & ENV 指到正確地址

你要落地的是兩個核心：
	1.	真實數據：價格 / 歷史 / 多鏈
	2.	穩定告警：有規則、有排程、有通知、有冷卻，不是 in-memory demo

⸻

2. 先決定 v0 的「能力邊界」

不然這個題目會爆炸。

我會建議你先定一個 v0 能力（對齊你現在骨架）：
	•	支援 1 條主鏈（例如 Ethereum Mainnet）
	•	支援 固定一批藍籌 ERC20（寫在 .env 的 ERC20_TOKENS）
	•	Portfolio / Dashboard：
	•	能顯示：每個錢包目前持有的 Token 數量 + 實時 USD 價值
	•	能顯示：最近 7 天 / 30 天 的總資產曲線（從自己 DB 的快照算）
	•	回測：
	    至少一種簡單策略（例如單幣 MA 或單幣 Buy & Hold）
	    使用真實價格歷史（鏈上 or Oracle or 價格 API）
	•	告警：
	    先做兩個 rule：
        1.	單幣暴露 > X%（例如 ETH/USDC 某一個超過 60%）
        2.	Portfolio 1 日跌幅 > Y%
	•	告警寫入 DB，有「已觸發」紀錄
	•	有冷卻：同一條 rule 對同一個 portfolio，不在冷卻時間內重複觸發

其他多鏈、多策略、清算風險可以放到 v1 / v2。

⸻

3. 按模組拆「你接下來該做什麼」

3-1. 價格：從 static TOKEN_PRICES → 真實 price oracle

目標：
後端任何地方只透過一個 interface 拿價格，實作可以換。

你需要做的事（設計層級，不寫 code）：
	1.	在 backend 建一個 Price Oracle abstraction
	  •	概念類似：
        PriceOracle trait / interface：get_spot_price(chain_id, token_address) -> Result<Price>
        原本的 StaticPriceOracle 變成這個 interface 的一個實作，專門讀 TOKEN_PRICES
	2.	決定 v0 的價格來源
	  •	你說「完全去中心化」：
      	那 v0 可以先用 單一 DEX 池子價格 + 或 鏈上 oracle（例如 Chainlink）
      	不想那麼硬，可以先：
      	API (Coingecko 或 Defillama) → 在你這邊落地成 cache table
      	每 X 秒/分更新，不要每次請求都打外部 API
	3.	在 DB 加一張 price cache / history 表
	  •	欄位概念：
      	chain_id, token_address, price_usd, source, timestamp
      	Portfolio 查詢 / 回測引擎都只看這裡，不直接打外部 API
	4.	把目前讀 TOKEN_PRICES 的地方全部改成走 PriceOracle
	  •	確保：
      	第一版沒接好外部，也可以回退到 Static（讀 .env）
      	但架構上已經抽象好了，未來要換 on-chain source 不會爆炸

⸻

3-2. Portfolio Indexer：從「當下餘額」→「可回溯的資產曲線」

目標：
有一個穩定的背景 job，定期把每個 portfolio 的狀態刻到 DB，讓你可以畫 TVL & PnL。

你要做的事：
	1.	固化 Indexer 的職責
	•	DbPortfolioService::spawn_indexer 的 job：
	•	每 X 秒/分鐘：
	•	走所有 active wallets / portfolios
	•	用 RPC 抓餘額 → 再用 Price Oracle 算出 USD 值
	•	寫入：
	•	portfolio_snapshots（新的表）
	•	portfolio_id, total_value_usd, timestamp
	•	optional: breakdown per token
	2.	決定「時間粒度」
	•	v0 可以先：
	•	每 5 分鐘 / 15 分鐘打一個 snapshot
	•	或者「當某個值變化超過 Y% 時」才加一筆（後面再說）
	3.	把「即時查詢」和「歷史查詢」分開
	•	Dashboard：
	•	live panel：直接從最新餘額現算（現在你在做的）
	•	chart panel：查 snapshot 表
	•	回測若用 portfolio 自己的歷史，也可以看 snapshot 表
	4.	多鏈準備（先不用實作）：
	•	在 Wallet / Portfolio 表裡確認是否已經有 chain_id
	•	如果沒有，現在是最佳時機加欄位，但 v0 可以只寫主鏈常數

⸻

3-3. 策略回測：從「隨機序列」→「真實歷史序列」

目標：
回測時，策略引擎拿的是「一條乾淨的歷史價格 / 資產曲線」，不是亂數。

你該做的：
	1.	決定回測的「資料源頭」
	•	選一條路（你先選一個就好）：
	•	A. 用你自己 price_history 表（由外部 API / on-chain oracle 事先抓好）
	•	B. 直接從鏈上解 DEX 池子的 price（難度高很多）
以「先跑得動」為前提，我會建議 v0：
A 路：先有一條 price_history
每小時/分鐘抓一次價格 → 寫 DB → 回測從 DB 抽
	2.	定義回測引擎的入參結構
	•	把現在 strategies.rs 內部「生成隨機序列」的那段邏輯抽掉
	•	新的設計：
	•	API 接到回測請求時：
	•	解析：資產 / 時間區間 / 策略參數
	•	呼叫一個 PriceSeriesProvider：
	•	get_series(chain_id, token, from, to, granularity) -> Vec<(timestamp, price)>
	•	把這個 series 丟給策略引擎
	3.	策略引擎和資料來源解耦
	•	策略引擎 不應該自己去查價格
	•	它只接「一條時間線上的價格 / 狀態序列」，然後輸出：
	•	PnL 曲線
	•	最大回撤
	•	其他風險指標

⸻

3-4. 告警：從 in-memory → DB + worker + 冷卻

目標：
告警引擎變成一個「可長時間跑的服務 / worker」，不會因為重啟就失憶，且有冷卻邏輯。

你該做的：
	1.	把 Alert Engine 的規則邏輯收斂成介面
	•	比方說有一個：
	•	AlertRule: evaluate(portfolio_snapshot, context) -> Option<AlertTrigger>
	•	各種規則（大跌、單幣暴露）只是不同的實作
	2.	決定觸發頻率：
	•	短期可以先：
	•	當新的 snapshot 被寫入時 → fire-and-forget 一次 evaluate
	•	或獨立 tokio task 每 X 秒掃一次最新 snapshot
	3.	冷卻與去重設計：
	•	在 DB / 表結構層級：
	•	每條 Alert 設：
	•	last_triggered_at
	•	cooldown_seconds
	•	evaluate 結果寫入：
	•	alert_events（AlertHistory）
	•	並更新 alerts 上的 last_triggered_at
	4.	通知管道先用「假的」
	•	v0 先只：
	•	寫 DB
	•	API 讓前端能抓「過去 24h 觸發紀錄」
	•	等到這套穩定後，再掛 Slack / Telegram / Email notifier

⸻

3-5. Auth / RoleManager：從「能查」→「能穩定用」

這塊你其實差一步：
	1.	確認 RoleManager.sol 已經在本地/測試鏈部署
	•	跑 Hardhat / Anvil，部署完地址寫進 .env 的 ROLE_MANAGER_ADDRESS
	2.	幫 Role cache 設 TTL 策略
	•	確保：
	•	SIWE / Session 進來時只在第一次打鏈上，之後從 cache 出
	•	TTL 到期或使用者手動 refresh 才重查
	3.	管理介面：
	•	前端 /admin 做一個「重新同步角色」按鈕 → call API → 清 cache + 重查

這樣角色邏輯就可以跟你後面策略 / 告警權限綁在一起。

⸻

3-6. 前端：從「能顯示」→「能說明現實世界」

你現在 Next/MUI 已經串 API 了，v0 要補的是：
	1.	Dashboard：
	•	上半部：
	•	各資產 current value + 占比（用真實價格）
	•	下半部：
	•	Portfolio TVL 歷史線（用 snapshot）
	•	Alert 觸發列表（最近 24h）
	•	加一個「數據來源說明」：
	•	價格從哪裡來（API or on-chain）
	•	更新頻率是多少
	2.	策略頁：
	•	回測結果顯示：
	•	累積報酬曲線
	•	最大回撤
	•	年化 / Sharpe（可以先顯示固定幾個）
	3.	錯誤 / 空資料狀態
	•	如果 backend 目前沒有 price / snapshot：
	•	顯示「正在建構歷史資料…」之類的狀態，而不是白板

⸻

4. 你可以照這樣的節奏來做（對齊你貼的「落地步驟」，但更貼你的 repo）

第 0 段（現在就可以做）
	•	把 Price Oracle 抽象出來（還不用接真實來源）
	•	幫 portfolio indexer 增加「寫 snapshot 表」的概念（even 只是存靜態價格先）

第 1 段：讓 Dashboard 至少看到「真實 spot 價格」
	•	決定 v0 價格來源（外部 API or 單一 oracle）
	•	做一個簡單 cron / task：
	•	每 1 分鐘更新 price_history / price_cache
	•	把現在所有用 TOKEN_PRICES 的地方改成走 PriceOracle

第 2 段：打通 snapshot + 前端歷史曲線
	•	強化 DbPortfolioService：
	•	週期性寫 snapshot
	•	Dashboard 接 /portfolio/snapshots API 畫線圖

第 3 段：用真實價格跑回測
	•	回測 API 改用 PriceSeriesProvider 讀 price_history
	•	策略引擎只吃 series，不自己造價

第 4 段：告警穩定化
	•	把 in-memory alert_engine 改成：
	•	消費 snapshot → evaluate → 寫 alert_events
	•	前端加「告警列表」
